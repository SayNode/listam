#!/usr/bin/env node
// Generates app/components/itemTranslations.ts from assets/data/grocery_categories_translated.csv
// Maps every non-English item text (lowercased) -> canonical English item text (lowercased)

import fs from 'fs'
import path from 'path'
import { fileURLToPath } from 'url'

const __dirname = path.dirname(fileURLToPath(import.meta.url))
const csvPath = path.join(__dirname, '../assets/data/grocery_categories_translated.csv')
const outPath = path.join(__dirname, '../app/components/itemTranslations.ts')

const LANGS = ['it', 'de', 'nl', 'es', 'pt', 'fr', 'zh', 'ru', 'ja', 'ko', 'ar', 'hi']

const text = fs.readFileSync(csvPath, 'utf8')
const lines = text.split('\n').filter(l => l.trim())
const header = lines[0].split(',')

const itemEnIdx = header.indexOf('item_en')
const langColIdx = {}
for (const lang of LANGS) {
    langColIdx[lang] = header.indexOf(`item_${lang}`)
}

// translatedToEn: translated_item_lowercased -> english_item_lowercased
const translatedToEn = {}

for (let i = 1; i < lines.length; i++) {
    const cols = lines[i].split(',')
    const enItem = cols[itemEnIdx]?.trim().toLowerCase()
    if (!enItem) continue

    for (const lang of LANGS) {
        const translated = cols[langColIdx[lang]]?.trim().toLowerCase()
        if (!translated || translated === enItem) continue
        // Only add if not already mapped (first occurrence wins)
        if (!translatedToEn[translated]) {
            translatedToEn[translated] = enItem
        }
    }
}

const entries = Object.entries(translatedToEn)
    .map(([k, v]) => `    ${JSON.stringify(k)}: ${JSON.stringify(v)},`)
    .join('\n')

const output = `// AUTO-GENERATED by scripts/generate-item-translations.mjs â€” do not edit manually
// Source: assets/data/grocery_categories_translated.csv
// Maps non-English item text (lowercased) to canonical English item text (lowercased)

export const TRANSLATED_ITEM_TO_EN: Record<string, string> = {
${entries}
}
`

fs.writeFileSync(outPath, output)
console.log(`Wrote ${outPath}`)
console.log(`Translation entries: ${entries.split('\n').length}`)
